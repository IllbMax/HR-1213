3. Leistungsoptimierung
Für die Analyse des Ausgangsprogramms mit gprof ergab sich folgendes Ergebnis:

  %   cumulative   self              self     total
 time   seconds   seconds    calls  ms/call  ms/call  name
 82.60      0.66     0.66        1   660.82   790.98  calculate
 16.27      0.79     0.13 13024980     0.00     0.00  getResiduum
  1.25      0.80     0.01        1    10.01    10.01  initMatrices
  0.00      0.80     0.00        3     0.00     0.00  allocateMemory
  0.00      0.80     0.00        1     0.00     0.00  AskParams
  0.00      0.80     0.00        1     0.00     0.00  DisplayMatrix
  0.00      0.80     0.00        1     0.00     0.00  allocateMatrices
  0.00      0.80     0.00        1     0.00     0.00  displayStatistics
  0.00      0.80     0.00        1     0.00     0.00  freeMatrices
  0.00      0.80     0.00        1     0.00     0.00  initVariables

Wie zu sehen, nimmt calculate() 82,6% der Programmlaufzeit in Anspruch und 
getResiduum() wird über 13 Millionen Mal aufgerufen. In diesen Funktionen wird
also der Hauptansatzpunkt für Optimierungen sein. Die restlichen Funktionen können
vernachlässigt werden, da sie entweder kaum zur Ausführungszeit beitragen oder
wie initMatrices() wohl eher unwahrscheinlich verbessert werden können, da sie die 
benötigten Matrizen allokieren und initialisieren.

Da wir uns bei der Optimierung auf calculate() und getResiduum() beschränken verwenden
wir zur Zeitmessung, die in das Programm eingebaute Zeitangabe, da hier nur die Laufzeit von
calculate() und dem darin aufgerufenen getResiduum() misst.

Um auf eine aussagekräftige Programmlaufzeit für das Ursprungsprogramm zu kommen haben wir
folgende Aufrufparameter verwendet:

                     Threads  Gauss  Interlines  Störfkt != 0  Iteration   #Iterationen
Aufruf: partdiff-seq    1      1      250         2            2           350

Der geringe Interlines-Wert liegt darin begründet, dass bei zu hohen Interlines-Werten keine
Werte > 0 in der Matrixausgabe des Programms auftauchen und so die Korrektheit der Berechungen
nach Quelltextanpassungen nicht mehr garantiert werden kann.

Für die Messwerte wurden auf 3 Knoten je 1 Prozess mit dem Programm gestartet. Die Tabelle
mit den Messwerten folgt am Ende. Für jeden neuen Messpunkt wurden die jeweils vorherigen 
Anpassungen beibehalten. Alle Anpassungen in partdiff-seq.c

0 Anpassungen: Programm wie in Auslieferungszustand ausgeführt.

Compileroptimierungen:

1. Anpassung: Kompilieren mit Cflag -O2
2. Anpassung: Kompilieren mit Cflag -O3

Anpassung des Speicherzugriffsmuster:

3. Anpassung: Zeile 462: Neuer Pointer **Mat2 um den Zugriff auf Matrix[m2] 
zwischen zu speichern und bei star-Berechnung Speichersuchzeit einzusparen.

4. Anpassung: Zeile 482/491: Tauschen von j und i als Zählvaribalen, damit bei 
der Starberechung entsprechend der Kommentare i für die Zeilen und j für die 
Spalten der Matrix steht, da die Matrix zeilen- und nicht spaltenweise im
Speicher ablegt ist.

5. Anpassung: Zeile 493: Zugriff auf Matrix[m2][i][j] in mij zwischenspeichern, da 
zweimal (ursprünglich Zeile: 246, 262 ) auf den Wert zugegriffen wird und so Zugriffszeit eingespart
werden kann.

6. Anpassung: Zeile: 519: Vertauschen der Summanden in der Starberechung, so dass
erst auf Werte der gleiche Zeile zugegriffen wird, um mögliche Cache Misses zu vermeiden.

7. Anpassung: Zeile 528: Werte für PI * arguments->h und arguments->h * arguments->h bei
der Initialiersierung von calculation_arguments, ab Zeile 58 berechnen und für die
Residuumsberechnung zwischenspeichern, um ständige Neuberechnung der immer gleichen
Werte zu verhindern. Hierfür struct calculation_arguments in Zeile 35/36 erweitern.

8. Anpassung: ab Zeile 528: Residuumsberechnung in calculate() durchführen und nicht in 
Extrafunktion auslagern um Codesprünge zu unterbinden.

9. Sinuswerte für die Residuumsberechnung vor berechnen. Dazu dem struct calculation_arguments 
das Array mysin hinzugefügt (Z. 78). Dies in der Funkion initMysin()(Z. 261) mit Werten gefüllt
und schließlich auf die Werte in der calculate()-Funktioen zugegriffen (Z. 529)

10. Da die Matrizen gewisse Symmetrien aufweisen, sollte sich die 
Programmlaufzeit reduzieren lassen, indem man die betroffenen Matrizenteile
nur einmal berechnet. Dazu haben wir folgende Datenaufteilung vorgenommen:

Matrixverkleinerung:
->Gauss Seidel: 1/2    (A+B +C)
->Jakobi (f = 0): 1/4    (A + B)
->Jakobi(sin):  1/8      (A)

Übersicht über die Auftreilung der Matrix:
|  \             / |
|  A  \     /     |
|------- X        |
|  B  /      \    |
|  /      C      \|


Mathematische Optimierung:

11. Die Divison durch 4 in der residuums- und starberechnung entfernt und stattdessen
in der Starberechnung die Faktor 0.25 hinzugefügt.

Messwerte jeweils in Sekunden
#Anpassungen	1. Messung	2. Messung	3. Messung	Mittel		%
0		175.571878	176.320661	176.819564	176.237367	100
1		135.154170	135.762710	135.817688	135.578189	76.9
2		107.884175	108.029850	108.185823	108.243904	61.4		
3		107.980768	108.454113	109.562276	108.665719	61.7
4		95.482527	95.619103	96.025068	95.708899	54.3
5		95.413421	95.684210	97.421549	96.17306	54.6
6		97.514675	97.818344	98.507254	97.946757	55.6
7		94.614089	93.995899	95.394860	94.668282	53.7	
8		93.350470	93.828295	93.346180	93.508315       53.1	
9		16.678611	16.767020	16.773099	16.739576	9.5
10              22.622328	22.618751	22.706306	22.649128	12.9


Zwischen jeder Codeanpassung stimmte die Ausgabe der Matrixwerte stets mit der Ausgabe des 
Ursprungsprogramm überein.

Eine abschließende Analyse mit gprof (O3-Optimierung deaktivert, deswegen Erhöhung der Laufzeit) ergab folgendes:

index % time    self  children    called     name
                                                 <spontaneous>
[1]    100.0    0.00   35.85                 main [1]
               35.83    0.00       1/1           calculate [2]
                0.02    0.00       1/1           initMatrices [3]
                0.00    0.00       1/1           AskParams [5]
                0.00    0.00       1/1           initVariables [12]
                0.00    0.00       1/1           allocateMatrices [7]
                0.00    0.00       1/1           initMysin [11]
                0.00    0.00       1/1           displayStatistics [8]
                0.00    0.00       1/1           freeMysin [10]
                0.00    0.00       1/1           DisplayMatrix [6]
                0.00    0.00       1/1           freeMatrices [9]

Sorry für den teilweise hässlichen Code. Wir wollten die unsere einzelnen 
Schritte dokumentieren und haben uns für die teilweise sehr großen 
auskommentierten Blöcke entschieden. Insgesamt wurde der Quellcode nochmal
per indent neu formatiert, um etwas Lesbarkeit zu retten. 

